const char* const cudf_types_hpp = "cudf/types.hpp\n"
"/*\n"
" * Copyright (c) 2018-2019, NVIDIA CORPORATION.\n"
" *\n"
" * Licensed under the Apache License, Version 2.0 (the \"License\");\n"
" * you may not use this file except in compliance with the License.\n"
" * You may obtain a copy of the License at\n"
" *\n"
" *     http://www.apache.org/licenses/LICENSE-2.0\n"
" *\n"
" * Unless required by applicable law or agreed to in writing, software\n"
" * distributed under the License is distributed on an \"AS IS\" BASIS,\n"
" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
" * See the License for the specific language governing permissions and\n"
" * limitations under the License.\n"
" */\n"
"\n"
"#pragma once\n"
"\n"
"#ifndef CUDA_HOST_DEVICE_CALLABLE\n"
"#ifdef __CUDACC__\n"
"#define CUDA_HOST_DEVICE_CALLABLE __host__ __device__ inline\n"
"#define CUDA_DEVICE_CALLABLE __device__ inline\n"
"#else\n"
"#define CUDA_HOST_DEVICE_CALLABLE inline\n"
"#define CUDA_DEVICE_CALLABLE inline\n"
"#endif\n"
"#endif\n"
"\n"
"#include <cstddef>\n"
"#include <cstdint>\n"
"\n"
"/**---------------------------------------------------------------------------*\n"
" * @file types.hpp\n"
" * @brief Type declarations for libcudf.\n"
" *\n"
" *---------------------------------------------------------------------------**/\n"
"\n"
"/**---------------------------------------------------------------------------*\n"
" * @brief Forward declaration of cudaStream_t\n"
" *---------------------------------------------------------------------------**/\n"
"using cudaStream_t = struct CUstream_st*;\n"
"\n"
"namespace bit_mask {\n"
"using bit_mask_t = uint32_t;\n"
"}\n"
"\n"
"// Forward declarations\n"
"namespace rmm {\n"
"class device_buffer;\n"
"namespace mr {\n"
"class device_memory_resource;\n"
"device_memory_resource* get_default_resource();\n"
"}  // namespace mr\n"
"\n"
"}  // namespace rmm\n"
"\n"
"namespace cudf {\n"
"\n"
"// Forward declaration\n"
"struct table;\n"
"class column;\n"
"class column_view;\n"
"class mutable_column_view;\n"
"class string_view;\n"
"\n"
"class scalar;\n"
"template <typename T> class numeric_scalar;\n"
"class string_scalar;\n"
"template <typename T> class timestamp_scalar;\n"
"\n"
"template <typename T> class numeric_scalar_device_view;\n"
"class string_scalar_device_view;\n"
"template <typename T> class timestamp_scalar_device_view;\n"
"\n"
"\n"
"\n"
"namespace experimental {\n"
"class table;\n"
"}\n"
"class table_view;\n"
"class mutable_table_view;\n"
"\n"
"using size_type = int32_t;\n"
"using bitmask_type = uint32_t;\n"
"using valid_type = uint8_t;\n"
"\n"
"/**---------------------------------------------------------------------------*\n"
" * @brief Indicates an unknown null count.\n"
" *\n"
" * Use this value when constructing any column-like object to indicate that\n"
" * the null count should be computed on the first invocation of `null_count()`.\n"
" *---------------------------------------------------------------------------**/\n"
"static constexpr size_type UNKNOWN_NULL_COUNT{-1};\n"
"\n"
"/**---------------------------------------------------------------------------*\n"
" * @brief Indicates the order in which elements should be sorted.\n"
" *---------------------------------------------------------------------------**/\n"
"enum class order : bool {\n"
"  ASCENDING,  ///< Elements ordered from small to large\n"
"  DESCENDING  ///< Elements ordered from large to small\n"
"};\n"
"\n"
"/**---------------------------------------------------------------------------*\n"
" * @brief Indicates how null values compare against all other values.\n"
" *---------------------------------------------------------------------------**/\n"
"enum class null_order : bool {\n"
"  AFTER,  ///< NULL values ordered *after* all other values\n"
"  BEFORE  ///< NULL values ordered *before* all other values\n"
"};\n"
"\n"
"/**---------------------------------------------------------------------------*\n"
" * @brief Controls the allocation/initialization of a null mask.\n"
" *---------------------------------------------------------------------------**/\n"
"enum mask_state {\n"
"  UNALLOCATED,    ///< Null mask not allocated, (all elements are valid)\n"
"  UNINITIALIZED,  ///< Null mask allocated, but not initialized\n"
"  ALL_VALID,      ///< Null mask allocated, initialized to all elements valid\n"
"  ALL_NULL        ///< Null mask allocated, initialized to all elements NULL\n"
"};\n"
"\n"
"namespace experimental{\n"
"/**\n"
" * @brief Interpolation method to use when the desired quantile lies between\n"
" * two data points i and j\n"
" *\n"
" */\n"
"enum class interpolation {\n"
"    LINEAR,  ///< Linear interpolation between i and j\n"
"    LOWER,       ///< Lower data point (i)\n"
"    HIGHER,      ///< Higher data point (j)\n"
"    MIDPOINT,    ///< (i + j)/2\n"
"    NEAREST      ///< i or j, whichever is nearest\n"
"};\n"
"}\n"
"/**---------------------------------------------------------------------------*\n"
" * @brief Identifies a column's logical element type\n"
" *---------------------------------------------------------------------------**/\n"
"enum type_id {\n"
"  EMPTY = 0,  ///< Always null with no underlying data\n"
"  INT8,       ///< 1 byte signed integer\n"
"  INT16,      ///< 2 byte signed integer\n"
"  INT32,      ///< 4 byte signed integer\n"
"  INT64,      ///< 8 byte signed integer\n"
"  FLOAT32,    ///< 4 byte floating point\n"
"  FLOAT64,    ///< 8 byte floating point\n"
"  BOOL8,      ///< Boolean using one byte per value, 0 == false, else true\n"
"  TIMESTAMP_DAYS,     ///< days since Unix Epoch in int32\n"
"  TIMESTAMP_SECONDS,  ///< duration of seconds since Unix Epoch in int64\n"
"  TIMESTAMP_MILLISECONDS,  ///< duration of milliseconds since Unix Epoch in int64\n"
"  TIMESTAMP_MICROSECONDS,  ///< duration of microseconds since Unix Epoch in int64\n"
"  TIMESTAMP_NANOSECONDS,  ///< duration of nanoseconds since Unix Epoch in int64\n"
"  CATEGORY,   ///< Categorial/Dictionary type\n"
"  STRING,     ///< String elements\n"
"  // `NUM_TYPE_IDS` must be last!\n"
"  NUM_TYPE_IDS  ///< Total number of type ids\n"
"};\n"
"\n"
"/**---------------------------------------------------------------------------*\n"
" * @brief Indicator for the logical data type of an element in a column.\n"
" *\n"
" * Simple types can be be entirely described by their `id()`, but some types\n"
" * require additional metadata to fully describe elements of that type.\n"
" *---------------------------------------------------------------------------**/\n"
"class data_type {\n"
" public:\n"
"  data_type() = default;\n"
"  ~data_type() = default;\n"
"  data_type(data_type const&) = default;\n"
"  data_type(data_type&&) = default;\n"
"  data_type& operator=(data_type const&) = default;\n"
"  data_type& operator=(data_type&&) = default;\n"
"\n"
"  /**---------------------------------------------------------------------------*\n"
"   * @brief Construct a new `data_type` object\n"
"   *\n"
"   * @param id The type's identifier\n"
"   *---------------------------------------------------------------------------**/\n"
"  explicit constexpr data_type(type_id id) : _id{id} {}\n"
"\n"
"  /**---------------------------------------------------------------------------*\n"
"   * @brief Returns the type identifier\n"
"   *---------------------------------------------------------------------------**/\n"
"  CUDA_HOST_DEVICE_CALLABLE type_id id() const noexcept { return _id; }\n"
"\n"
" private:\n"
"  type_id _id{EMPTY};\n"
"  // Store additional type specific metadata, timezone, decimal precision and\n"
"  // scale, etc.\n"
"};\n"
"\n"
"/**---------------------------------------------------------------------------*\n"
" * @brief Compares two `data_type` objects for equality.\n"
" *\n"
" * // TODO Define exactly what it means for two `data_type`s to be equal. e.g.,\n"
" * are two timestamps with different resolutions equal? How about decimals with\n"
" * different scale/precision?\n"
" *\n"
" * @param lhs The first `data_type` to compare\n"
" * @param rhs The second `data_type` to compare\n"
" * @return true `lhs` is equal to `rhs`\n"
" * @return false `lhs` is not equal to `rhs`\n"
" *---------------------------------------------------------------------------**/\n"
"inline bool operator==(data_type const& lhs, data_type const& rhs) {\n"
"  return lhs.id() == rhs.id();\n"
"}\n"
"\n"
"/**\n"
" * @brief Returns the size in bytes of elements of the specified `data_type`\n"
" *\n"
" * @note Only fixed-width types are supported\n"
" *\n"
" * @throws cudf::logic_error if `is_fixed_width(element_type) == false`\n"
" *\n"
" * @return Size in bytes of an element of the specified `data_type`\n"
" */\n"
"std::size_t size_of(data_type t);\n"
"\n"
"}  // namespace cudf\n"
;
